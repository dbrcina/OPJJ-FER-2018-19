package hr.fer.zemris.java.search_engine;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import hr.fer.zemris.java.console.messages.ConsoleMessage;
import hr.fer.zemris.java.math.NDimensionalVector;
import hr.fer.zemris.java.model.DocumentModel;
import hr.fer.zemris.java.model.Result;
import hr.fer.zemris.java.util.Util;
import hr.fer.zemris.java.visitors.DocumentVisitor;

/**
 * Simulation of <b><i>"google-like"</i></b> search engine which provides some
 * generic console commands(every other input is invalid):
 * <ol>
 * 
 * <li><b>QUERY</b>:<br>
 * Takes arbitrary number of arguments that needs to be some regular words from
 * vocabulary and executes search of all documents and finds 10 results by
 * <i>tfidf similarity calculation</i> which then are written to the
 * console.<br>
 * <b><i>Semantic similarity</i></b> is nothing more than cosinus of angle
 * between two <i>tdidf vectors</i>.<br>
 * If no arguments are provided, an appropriate message is sent to the
 * console.<br>
 * If any of provided words is not a valid word <i>(i.e
 * {@link Util#parseWord(String)} returns an empty array)</i> or is not in a
 * vocabulary, it is ignored.</li>
 * 
 * <li><b>TPYE</b>:<br>
 * Takes one argument, index of a result generated by <i>QUERY</i> command and
 * reads content from it and writes it to the console.<br>
 * If argument is not provided or if there is more than one argument or provided
 * index is invalid, an appropriate message is sent to the console.</li>
 * 
 * <li><b>RESULTS</b>:<br>
 * Takes zero arguments and writes results that are generated by <i>QUERY</i>
 * command.</li>
 * 
 * <li><b>EXIT</b>:<br>
 * Exits the console.</li>
 * </ol>
 * 
 * <p>
 * When a program starts, global vocabulary is prepared alongside with
 * <b><i>tfidf-vector</i></b> representations of every document. Valid
 * vocabulary words are those that are not <i>stopwords</i> and those for whom
 * {@link Util#parseWord(String)} method returns a non empty array.
 * </p>
 * 
 * <p>
 * Program expects one argument through command line, a path to some documents
 * folder.
 * </p>
 * 
 * @author dbrcina
 *
 * @see {@link DocumentModel} for further documentation on vectors.
 */
public class SearchEngine {

	/**
	 * Minimum value for result index.
	 */
	private static final int MIN_RESULT_INDEX = 0;
	/**
	 * Maximum value for result index.
	 */
	private static final int MAX_RESULT_INDEX = 9;
	/**
	 * Name of the <i>txt</i> folder where all <i>stopwords</i> are stored.
	 */
	private static final String STOP_WORDS = "src/main/resources/hrvatski_stoprijeci.txt";
	/**
	 * List of <i>stopwords</i>.
	 */
	private static List<String> stopwords = new ArrayList<>();
	/**
	 * Instance of {@link Map} which represents generated vocabulary from all
	 * documents.<br>
	 * Key values are <i>words</i> and values are positions of <i>n-dimensional</i>
	 * vector.
	 */
	private static Map<String, Integer> vocabulary = new HashMap<>();
	/**
	 * List of documents.
	 */
	private static List<DocumentModel> documents = new ArrayList<>();
	/**
	 * <i>idf-vector</i> representation of all words.
	 */
	private static Map<String, Double> idfVector = new HashMap<>();
	/**
	 * List of results after query command is executed.
	 */
	private static List<Result> results = new ArrayList<>();

	/**
	 * Getter for <i>idf-vector</i>.
	 * 
	 * @return idf vector.
	 */
	public static Map<String, Double> getIDFVector() {
		return idfVector;
	}

	/**
	 * Adds provided <i>document</i> into list of documents.
	 * 
	 * @param document document.
	 * @return <i>true</i> if adding was successful, otherwise <i>false</i>.
	 */
	public static boolean addDocument(DocumentModel document) {
		return documents.add(document);
	}

	/**
	 * Getter for list of documents.
	 * 
	 * @return list of documents.
	 */
	public static List<DocumentModel> getDocuments() {
		return documents;
	}

	/**
	 * Getter for global vocabulary.
	 * 
	 * @return {@link #vocabulary}.
	 */
	public static Map<String, Integer> getVocabulary() {
		return vocabulary;
	}

	/**
	 * Getter for list of stopwords.
	 * 
	 * @return list of stopwords.
	 */
	public static List<String> getStopwords() {
		return stopwords;
	}

	/**
	 * Main entry of this program.<br>
	 * It expects one argument through command line, a path to documents folder.<br>
	 * If path is invalid, an appropriate message is sent to the user.
	 * 
	 * @param args arguments through command line.
	 * @throws IOException if error occurs while reading from a file.
	 */
	public static void main(String[] args) throws IOException {
		if (args.length != 1) {
			System.out.println("Program expects one argument through command line, a path to some directory...");
			System.exit(-1);
		}

		Path docFolder = null;
		try {
			docFolder = Paths.get(args[0]);
		} catch (Exception e) {
			System.out.println("Provided argument cannot be converted to path");
			System.exit(-1);
		}

		if (!Files.exists(docFolder)) {
			System.out.println("Provided path doesn't exist");
			System.exit(-1);
		}

		prepareResources(docFolder);
		userConsole();
	}

	/**
	 * Helper method which prepares all resources upon start of this program.
	 * 
	 * @param docFolder document folder.
	 * @throws IOException if something goes wrong while reading from a file.
	 */
	private static void prepareResources(Path docFolder) throws IOException {
		// read all stopwords
		stopwords = Files.readAllLines(Paths.get(STOP_WORDS));
		// prepare vocabulary and tf vectors for every document
		Files.walkFileTree(docFolder, new DocumentVisitor());
		// prepare global idf vector and tfidf vectors for every document
		documents.forEach(d -> d.vectorize());
	}

	/**
	 * Method which simulates <i>"shell-like"</i> console.
	 * 
	 * @throws IOException if something goes wrong while reading from a file.
	 * 
	 * @see {@link SearchEngine} for documentation.
	 */
	private static void userConsole() throws IOException {
		System.out.println(ConsoleMessage.WELCOME_MSG);
		System.out.println("Veličina riječnika je " + vocabulary.size() + " riječi.\n");
		try (Scanner sc = new Scanner(System.in)) {
			while (true) {
				System.out.print(ConsoleMessage.INPUT_CMD_MSG);

				String command = sc.nextLine().trim().toLowerCase();

				if (command.isEmpty()) {
					continue;
				}

				String[] parts = command.split("\\s+");
				switch (parts[0]) {
				case "query":
					queryCommand(parts);
					break;
				case "type":
					typeCommand(parts);
					break;
				case "results":
					resultsCommand(parts);
					break;
				case "exit":
					exitCommand(parts);
					break;
				default:
					System.out.println(ConsoleMessage.INVALID_CMD_MSG);
				}
			}
		}
	}

	/**
	 * Performs <b><i>query</i></b> command.
	 * 
	 * @param parts arguments.
	 */
	private static void queryCommand(String[] parts) {
		results.clear();

		if (parts.length == 1) {
			System.out.println(ConsoleMessage.QUERY_INV_ARG);
			return;
		}

		List<String> queryWords = new ArrayList<>(Arrays.asList(Arrays.copyOfRange(parts, 1, parts.length)));
		queryWords = parseQuery(queryWords);

		queryWords.removeIf(word -> !vocabulary.containsKey(word));
		System.out.println("Query is: " + queryWords);

		if (queryWords.isEmpty()) {
			System.out.println(ConsoleMessage.NO_RESULTS);
			return;
		}

		NDimensionalVector tfidfQuery = TFIDFQuery(queryWords);
		semanticSimilarity(tfidfQuery);

		printResults();
	}

	/**
	 * Performs <b><i>type</i></b> command.
	 * 
	 * @param parts arguments.
	 * @throws IOException if something goes wrong while reading from a file.
	 */
	private static void typeCommand(String[] parts) throws IOException {
		Integer i;
		if (parts.length != 2 || (i = parse(parts[1])) == null) {
			System.out.println(ConsoleMessage.TYPE_INV_ARG);
			return;
		}
		if (results.isEmpty()) {
			System.out.println(ConsoleMessage.TYPE_ERROR);
			return;
		}
		if (i < MIN_RESULT_INDEX || i > MAX_RESULT_INDEX || i > results.size() - 1) {
			System.out.println(ConsoleMessage.TYPE_INDEX_ERROR);
			return;
		}

		Path path = results.get(i).getPath();
		System.out.println("Dokument:" + path);
		Files.readAllLines(results.get(i).getPath()).forEach(System.out::println);
	}

	/**
	 * Performs <b><i>results</i></b> command.
	 * 
	 * @param parts arguments.
	 */
	private static void resultsCommand(String[] parts) {
		if (parts.length != 1) {
			System.out.println(ConsoleMessage.RESULTS_INV_ARG);
			return;
		}
		if (results.isEmpty()) {
			System.out.println(ConsoleMessage.NO_RESULTS);
			return;
		}

		printResults();
	}

	/**
	 * Performs <b><i>exit</i></b> command.
	 * 
	 * @param parts arguments.
	 */
	private static void exitCommand(String[] parts) {
		if (parts.length != 1) {
			System.out.println(ConsoleMessage.EXIT_INV_ARG);
			return;
		}
		System.out.println(ConsoleMessage.END_MSG);
		System.exit(0);
	}

	/**
	 * Helper method used for parsing query arguments with the help of
	 * {@link Util#parseWord(String)} method.
	 * 
	 * @param queryWords query words.
	 * @return list of parsed query arguments.
	 */
	private static List<String> parseQuery(List<String> queryWords) {
		List<String> parsed = new ArrayList<>();
		for (String word : queryWords) {
			String[] parts = Util.parseWord(word);
			parsed.addAll(Arrays.asList(parts));
		}
		return parsed;
	}

	/**
	 * Creates <i>tfidf-vector</i> from query input.
	 * 
	 * @param queryWords list of query words.
	 * @return <i>tfidf-vector</i>.
	 */
	private static NDimensionalVector TFIDFQuery(List<String> queryWords) {
		NDimensionalVector tfidfQuery = new NDimensionalVector(vocabulary.size());
		var tfQuery = TFQuery(queryWords);
		for (String word : queryWords) {
			int index = vocabulary.get(word);
			double value = tfQuery.get(word) * idfVector.get(word);
			tfidfQuery.registerValue(value, index);
		}
		return tfidfQuery;
	}

	/**
	 * Creates <i>tf-vector</i> from query input.
	 * 
	 * @param queryWords list of query words.
	 * @return <i>tf-vector</i>.
	 */
	private static Map<String, Integer> TFQuery(List<String> queryWords) {
		DocumentModel document = new DocumentModel(null);
		queryWords.forEach(word -> document.registerWord(word));
		return document.getWords();
	}

	/**
	 * Calculates semantic similarity between <i>tfidfQuery</i> vector and all
	 * documents and saves the result into {@link #results} list.
	 * 
	 * @param tfidfQuery <i>tfidf-vector</i> representation of query.
	 */
	private static void semanticSimilarity(NDimensionalVector tfidfQuery) {
		for (var document : documents) {
			double semanticSimilarity = document.getTFIDFVector().cosAngle(tfidfQuery);
			if (semanticSimilarity != 0 && !Double.isNaN(semanticSimilarity)) {
				results.add(new Result(document.getPath(), semanticSimilarity));
			}
		}
		Collections.sort(results);
	}

	/**
	 * Prints results of <b><i>query</i></b> command onto {@link System#out}.
	 */
	private static void printResults() {
		System.out.println("Najboljih 10 rezultata:");
		for (int i = MIN_RESULT_INDEX; i <= MAX_RESULT_INDEX && i < results.size(); i++) {
			System.out.println("[ " + i + "] " + results.get(i));
		}
		System.out.println();
	}

	/**
	 * Parses provided <i>value</i> into integer.
	 * 
	 * @param value value.
	 * @return parsed valued if it is parsable, otherwise <i>null</i>.
	 */
	private static Integer parse(String value) {
		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException e) {
			return null;
		}
	}
}
